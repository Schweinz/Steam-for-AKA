import random
import time

def recommend_games_iterative(games, budget, min_rating):
    """
    Iterative approach to recommend games based on budget and minimum rating.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        budget (float): Maximum amount the user is willing to spend.
        min_rating (float): Minimum acceptable rating.

    Returns:
        list of dict: Games that match the criteria.
    """
    recommendations = []
    for game in games:
        if game['price'] <= budget and game['rating'] >= min_rating:
            recommendations.append(game)
    return recommendations

def recommend_games_recursive(games, budget, min_rating, index=0, recommendations=None):
    """
    Recursive approach to recommend games based on budget and minimum rating.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        budget (float): Maximum amount the user is willing to spend.
        min_rating (float): Minimum acceptable rating.
        index (int): Current index in the games list.
        recommendations (list of dict): Accumulated recommendations.

    Returns:
        list of dict: Games that match the criteria.
    """
    if recommendations is None:
        recommendations = []
    if index == len(games):
        return recommendations
    if games[index]['price'] <= budget and games[index]['rating'] >= min_rating:
        recommendations.append(games[index])
    return recommend_games_recursive(games, budget, min_rating, index + 1, recommendations)

def sort_games_iterative(games, key):
    """
    Iterative approach to sort games by a specified key.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        key (str): The key to sort the games by ('price' or 'rating').

    Returns:
        list of dict: Sorted list of games.
    """
    for i in range(len(games)):
        for j in range(len(games) - i - 1):
            if games[j][key] > games[j + 1][key]:
                games[j], games[j + 1] = games[j + 1], games[j]
    return games

def sort_games_recursive(games, key, n=None):
    """
    Recursive approach to sort games by a specified key.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        key (str): The key to sort the games by ('price' or 'rating').
        n (int): Current length of the unsorted portion of the list.

    Returns:
        list of dict: Sorted list of games.
    """
    if n is None:
        n = len(games)
    if n <= 1:
        return games
    for i in range(n - 1):
        if games[i][key] > games[i + 1][key]:
            games[i], games[i + 1] = games[i + 1], games[i]
    return sort_games_recursive(games, key, n - 1)

# Generate 1000 sample games
games = []
for i in range(1, 1001):
    games.append({
        "name": f"Game {i}",
        "price": round(random.uniform(1, 60), 2),
        "rating": round(random.uniform(1, 5), 1)
    })

def main():
    # User inputs
    try:
        budget = float(input("Enter your budget (in USD): "))
        min_rating = float(input("Enter the minimum acceptable rating (1-5): "))
        search_method = input("Choose search method (iterative/recursive): ").strip().lower()
        sort_method = input("Choose sorting method (iterative/recursive): ").strip().lower()

        # Measure search time
        start_time = time.time()
        if search_method == "iterative":
            recommendations = recommend_games_iterative(games, budget, min_rating)
        elif search_method == "recursive":
            recommendations = recommend_games_recursive(games, budget, min_rating)
        else:
            raise ValueError("Invalid search method.")
        search_time = time.time() - start_time

        # Measure sort time
        start_time = time.time()
        if sort_method == "iterative":
            recommendations = sort_games_iterative(recommendations, "price")
        elif sort_method == "recursive":
            recommendations = sort_games_recursive(recommendations, "price")
        else:
            raise ValueError("Invalid sorting method.")
        sort_time = time.time() - start_time

        # Display results
        if recommendations:
            print("\nRecommended games:")
            for game in recommendations:
                print(f"- {game['name']} ($ {game['price']}, Rating: {game['rating']})")
        else:
            print("\nNo games match your criteria.")

        # Display timings
        print(f"\nSearch time ({search_method}): {search_time:.6f} seconds")
        print(f"Sort time ({sort_method}): {sort_time:.6f} seconds")

    except ValueError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
