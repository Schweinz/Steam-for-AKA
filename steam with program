import random
import time
import tkinter as tk
from tkinter import messagebox, simpledialog

def recommend_games_iterative(games, budget, min_rating):
    """
    Iterative approach to recommend games based on budget and minimum rating.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        budget (float): Maximum amount the user is willing to spend.
        min_rating (float): Minimum acceptable rating.

    Returns:
        list of dict: Games that match the criteria.
    """
    recommendations = []
    for game in games:
        if game['price'] <= budget and game['rating'] >= min_rating:
            recommendations.append(game)
    return recommendations

def recommend_games_recursive(games, budget, min_rating, index=0, recommendations=None):
    """
    Recursive approach to recommend games based on budget and minimum rating.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        budget (float): Maximum amount the user is willing to spend.
        min_rating (float): Minimum acceptable rating.
        index (int): Current index in the games list.
        recommendations (list of dict): Accumulated recommendations.

    Returns:
        list of dict: Games that match the criteria.
    """
    if recommendations is None:
        recommendations = []
    if index == len(games):
        return recommendations
    if games[index]['price'] <= budget and games[index]['rating'] >= min_rating:
        recommendations.append(games[index])
    return recommend_games_recursive(games, budget, min_rating, index + 1, recommendations)

def sort_games_iterative(games, key):
    """
    Iterative approach to sort games by a specified key.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        key (str): The key to sort the games by ('price' or 'rating').

    Returns:
        list of dict: Sorted list of games.
    """
    for i in range(len(games)):
        for j in range(len(games) - i - 1):
            if games[j][key] > games[j + 1][key]:
                games[j], games[j + 1] = games[j + 1], games[j]
    return games

def sort_games_recursive(games, key, n=None):
    """
    Recursive approach to sort games by a specified key.

    Args:
        games (list of dict): List of games with 'name', 'price', and 'rating'.
        key (str): The key to sort the games by ('price' or 'rating').
        n (int): Current length of the unsorted portion of the list.

    Returns:
        list of dict: Sorted list of games.
    """
    if n is None:
        n = len(games)
    if n <= 1:
        return games
    for i in range(n - 1):
        if games[i][key] > games[i + 1][key]:
            games[i], games[i + 1] = games[i + 1], games[i]
    return sort_games_recursive(games, key, n - 1)

def get_user_input(root, prompt, type_=float):
    while True:
        try:
            response = simpledialog.askstring("Input", prompt, parent=root)
            if response is None:
                return None
            return type_(response)
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid value.")

def main():
    # Generate 1000 sample games
    games = []
    for i in range(1, 1001):
        games.append({
            "name": f"Game {i}",
            "price": round(random.uniform(1, 60), 2),
            "rating": round(random.uniform(1, 5), 1)
        })

    root = tk.Tk()
    root.withdraw()  # Hide the main window

    # Get user input
    budget = get_user_input(root, "Enter your budget (in USD): ")
    if budget is None:
        return
    min_rating = get_user_input(root, "Enter the minimum acceptable rating (1-5): ")
    if min_rating is None:
        return
    search_method = simpledialog.askstring("Input", "Choose search method (iterative/recursive):", parent=root)
    if search_method is None:
        return
    sort_method = simpledialog.askstring("Input", "Choose sorting method (iterative/recursive):", parent=root)
    if sort_method is None:
        return

    # Perform search
    start_time = time.time()
    if search_method.lower() == "iterative":
        recommendations = recommend_games_iterative(games, budget, min_rating)
    elif search_method.lower() == "recursive":
        recommendations = recommend_games_recursive(games, budget, min_rating)
    else:
        messagebox.showerror("Error", "Invalid search method.")
        return
    search_time = time.time() - start_time

    # Perform sort
    start_time = time.time()
    if sort_method.lower() == "iterative":
        recommendations = sort_games_iterative(recommendations, "price")
    elif sort_method.lower() == "recursive":
        recommendations = sort_games_recursive(recommendations, "price")
    else:
        messagebox.showerror("Error", "Invalid sorting method.")
        return
    sort_time = time.time() - start_time

    # Display results
    if recommendations:
        results = "\n".join([f"- {game['name']} ($ {game['price']}, Rating: {game['rating']})" for game in recommendations])
        messagebox.showinfo("Recommended Games", results)
    else:
        messagebox.showinfo("Recommended Games", "No games match your criteria.")

    # Display timings
    timings = (
        f"Search time ({search_method}): {search_time:.6f} seconds\n"
        f"Sort time ({sort_method}): {sort_time:.6f} seconds"
    )
    messagebox.showinfo("Performance", timings)

if __name__ == "__main__":
    main()
