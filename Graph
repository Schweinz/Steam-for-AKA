import random
import time
import tkinter as tk
from tkinter import messagebox, simpledialog
import matplotlib.pyplot as plt

# Sample game names (used in the previous code)
game_names = [
    "Minecraft", "The Witcher 3", "Cyberpunk 2077", "Red Dead Redemption 2", "Hades", "Celeste", "The Last of Us Part II",
    "Doom Eternal", "The Elder Scrolls V: Skyrim", "Among Us", "God of War", "Sekiro: Shadows Die Twice", "Stardew Valley",
    "Fortnite", "League of Legends", "GTA V", "Valorant", "Apex Legends", "Overwatch", "The Legend of Zelda: Breath of the Wild",
    "Animal Crossing: New Horizons", "Dark Souls III", "Spider-Man: Miles Morales", "Hitman 3", "Ghost of Tsushima", "Nier: Automata"
] * 40  # Create 1000 game names by repeating the list

# Generate sample game data
def generate_games():
    games = []
    for i in range(1000):
        games.append({
            "name": game_names[i],
            "price": round(random.uniform(1, 60), 2),
            "rating": round(random.uniform(1, 5), 1)
        })
    return games

# Functions for iterative and recursive methods (same as previous code)
def recommend_games_iterative(games, budget, min_rating):
    recommendations = []
    for game in games:
        if game['price'] <= budget and game['rating'] >= min_rating:
            recommendations.append(game)
    return recommendations

def recommend_games_recursive(games, budget, min_rating, index=0, recommendations=None):
    if recommendations is None:
        recommendations = []
    if index == len(games):
        return recommendations
    if games[index]['price'] <= budget and games[index]['rating'] >= min_rating:
        recommendations.append(games[index])
    return recommend_games_recursive(games, budget, min_rating, index + 1, recommendations)

def sort_games_iterative(games, key):
    for i in range(len(games)):
        for j in range(len(games) - i - 1):
            if games[j][key] > games[j + 1][key]:
                games[j], games[j + 1] = games[j + 1], games[j]
    return games

def sort_games_recursive(games, key, n=None):
    if n is None:
        n = len(games)
    if n <= 1:
        return games
    for i in range(n - 1):
        if games[i][key] > games[i + 1][key]:
            games[i], games[i + 1] = games[i + 1], games[i]
    return sort_games_recursive(games, key, n - 1)

# Get user input
def get_user_input(root, prompt, type_=float):
    while True:
        try:
            response = simpledialog.askstring("Input", prompt, parent=root)
            if response is None:
                return None
            return type_(response)
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid value.")

# Main function to compare iterative vs recursive
def main():
    games = generate_games()

    root = tk.Tk()
    root.withdraw()  # Hide the main window

    # Get user input
    budget = get_user_input(root, "Enter your budget (in USD): ")
    if budget is None:
        return
    min_rating = get_user_input(root, "Enter the minimum acceptable rating (1-5): ")
    if min_rating is None:
        return
    search_method = simpledialog.askstring("Input", "Choose search method (iterative/recursive):", parent=root)
    if search_method is None:
        return
    sort_method = simpledialog.askstring("Input", "Choose sorting method (iterative/recursive):", parent=root)
    if sort_method is None:
        return

    # Measure time for searching and sorting
    search_times = {"iterative": 0, "recursive": 0}
    sort_times = {"iterative": 0, "recursive": 0}

    # Search using iterative method
    start_time = time.time()
    recommendations = recommend_games_iterative(games, budget, min_rating)
    search_times["iterative"] = time.time() - start_time

    # Search using recursive method
    start_time = time.time()
    recommendations_recursive = recommend_games_recursive(games, budget, min_rating)
    search_times["recursive"] = time.time() - start_time

    # Sort using iterative method
    start_time = time.time()
    recommendations_sorted_iterative = sort_games_iterative(recommendations, "price")
    sort_times["iterative"] = time.time() - start_time

    # Sort using recursive method
    start_time = time.time()
    recommendations_sorted_recursive = sort_games_recursive(recommendations, "price")
    sort_times["recursive"] = time.time() - start_time

    # Display results (timings)
    timings = (
        f"Search time (iterative): {search_times['iterative']:.6f} seconds\n"
        f"Search time (recursive): {search_times['recursive']:.6f} seconds\n"
        f"Sort time (iterative): {sort_times['iterative']:.6f} seconds\n"
        f"Sort time (recursive): {sort_times['recursive']:.6f} seconds"
    )
    messagebox.showinfo("Performance", timings)

    # Create line graph comparing iterative and recursive methods
    methods = ['Iterative', 'Recursive']
    search_values = [search_times['iterative'], search_times['recursive']]
    sort_values = [sort_times['iterative'], sort_times['recursive']]

    # Plotting the graph with lines
    plt.figure(figsize=(10, 6))
    plt.plot(methods, search_values, label='Search Time', marker='o', linestyle='-', color='b')
    plt.plot(methods, sort_values, label='Sort Time', marker='o', linestyle='-', color='g')
    plt.xlabel('Method')
    plt.ylabel('Time (seconds)')
    plt.title('Iterative vs Recursive: Search and Sort Time Comparison')
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()
